<!DOCTYPE html>

<html>

<head>
  <style>
    #info {
      position: absolute;
      top: 2%;
      width: 100%;
      padding: 10px;
      text-align: center;
      color: #ffff00
    }

    body {
      overflow: hidden;
    }
  </style>
</head>

<body>

  <script id="vsFilter" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
        vUv = uv;
    }
  </script>
  <script id="fsFilter" type="x-shader/x-fragment">
    uniform sampler2D texture;
    varying vec2 vUv;
  	uniform float grain;

    void main() {
    	vec2 uuvv = floor (vUv*grain)/grain;
    	gl_FragColor = texture2D(texture, uuvv);
    }
  </script>

  <script id="vsFilter2" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
        vUv = uv;
    }
  </script>
  <script id="fsFilter2" type="x-shader/x-fragment">
    uniform sampler2D texture;
    varying vec2 vUv;
    uniform vec2 center[100];
  	uniform float grain;
    uniform float radius;
    /*uniform vec2 center1;
    uniform vec2 center2;
    uniform vec2 center3;
    uniform vec2 center4;
    uniform vec2 center5;
    uniform vec2 center6;
    uniform vec2 center7;
    uniform vec2 center8;
    uniform vec2 center9;
    uniform vec2 center10;

    uniform vec2 center11;
    uniform vec2 center12;
    uniform vec2 center13;
    uniform vec2 center14;
    uniform vec2 center15;
    uniform vec2 center16;
    uniform vec2 center17;
    uniform vec2 center18;
    uniform vec2 center19;
    uniform vec2 center20;

    uniform vec2 center21;
    uniform vec2 center22;
    uniform vec2 center23;
    uniform vec2 center24;
    uniform vec2 center25;
    uniform vec2 center26;
    uniform vec2 center27;
    uniform vec2 center28;
    uniform vec2 center29;
    uniform vec2 center30;*/


    void main() {
      vec4 color;

      float dis[100];
      for(int i=0;i<100;i++){
        dis[i] = distance(vUv, center[i]);
      }
      /*float dis1 = distance(vUv, center1);
      float dis2 = distance(vUv, center2);
      float dis3 = distance(vUv, center3);
      float dis4 = distance(vUv, center4);
      float dis5 = distance(vUv, center5);
      float dis6 = distance(vUv, center6);
      float dis7 = distance(vUv, center7);
      float dis8 = distance(vUv, center8);
      float dis9 = distance(vUv, center9);
      float dis10 = distance(vUv, center10);

      float dis11 = distance(vUv, center11);
      float dis12 = distance(vUv, center12);
      float dis13 = distance(vUv, center13);
      float dis14 = distance(vUv, center14);
      float dis15 = distance(vUv, center15);
      float dis16 = distance(vUv, center16);
      float dis17 = distance(vUv, center17);
      float dis18 = distance(vUv, center18);
      float dis19 = distance(vUv, center19);
      float dis20 = distance(vUv, center20);

      float dis21 = distance(vUv, center21);
      float dis22 = distance(vUv, center22);
      float dis23 = distance(vUv, center23);
      float dis24 = distance(vUv, center24);
      float dis25 = distance(vUv, center25);
      float dis26 = distance(vUv, center26);
      float dis27 = distance(vUv, center27);
      float dis28 = distance(vUv, center28);
      float dis29 = distance(vUv, center29);
      float dis30 = distance(vUv, center30);*/
      int flag = 0;
      for(int i=0;i<100;i++){
        if(dis[i] < radius){
          vec2 uuvv = floor (vUv*grain)/grain;
          gl_FragColor = texture2D(texture, uuvv);
          flag = 1;
          break;
        }
      }
      if(flag == 0)discard;
      /*if(dis1 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis2 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis3 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis4 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis5 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis6 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis7 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis8 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis9 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis10 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis11 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis12 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis13 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis14 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis15 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis16 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis17 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis18 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis19 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis20 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis21 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis22 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis23 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis24 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis25 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis26 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis27 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis28 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis29 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else if(dis30 < radius){
        vec2 uuvv = floor (vUv*grain)/grain;
        color = texture2D(texture, uuvv);
      }
      else{
        //color = texture2D(texture, vUv);
        discard;
      }*/
      //gl_FragColor = color;
    	//vec2 uuvv = floor (vUv*grain)/grain;
      //gl_FragColor = texture2D(texture, vUv);
    }
  </script>

  <script src="js/libs/ammo.js"></script>
  <script type="module">

  import * as THREE from './build/three.module.js';
  import Stats from './jsm/libs/stats.module.js';
  import { OrbitControls } from './jsm/controls/OrbitControls.js';
  import { OutlineEffect } from './jsm/effects/OutlineEffect.js';
  import { MMDLoader } from './jsm/loaders/MMDLoader.js';
  import { MMDAnimationHelper } from './jsm/animation/MMDAnimationHelper.js';
	  var scene, renderer, camera, stats;
    var WIDTH, HEIGHT;
    var offset;
    var camera, scene, renderer, mesh, plan, plan2 = [], light;
    var bufferScene, bufferTexture, bufferCamera, material_shh, /*material_shh2,*/ LEDs = [], LEDNum = 50;
    var modelFile = 'models/serval/serval.pmx';
    var vmdFiles = 'vmds/servaldance.vmd';
    var loader, helper, ikHelper, physicsHelper, effect;
    var clock = new THREE.Clock();
    var angle = 0;


  Ammo().then(function(AmmoLib) {
    Ammo = AmmoLib;
  	init();
  	animate();
  });


	function init() {
	  scene = new THREE.Scene();
	  scene.background = new THREE.Color(0x000000);

	  renderer = new THREE.WebGLRenderer({antialias:true});
	   WIDTH = window.innerWidth;
	   HEIGHT = window.innerHeight;
	  renderer.setSize(WIDTH, HEIGHT);
	  //renderer.setClearColor(0x888888);
	  document.body.appendChild(renderer.domElement);

	  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.5, 1000);
	  //camera.position.z = 50;
	  camera.position.set(0,30,50);

    stats = new Stats();
    stats.showPanel(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild(stats.domElement);

	  let controls = new OrbitControls(camera, renderer.domElement);
  	controls.enableKeys = false;

    var light = new THREE.DirectionalLight(0xffffff);
    light.position.set(50, 100, 0);
    scene.add(light);

    effect = new OutlineEffect(renderer);

    var gridHelper = new THREE.GridHelper( 100, 50 , 'red', 'white');
    //scene.add(gridHelper);
    /////////

    ///////////////////
    bufferScene = new THREE.Scene();
    bufferScene.background = new THREE.Color(0x000000);
    //bufferCamera= new THREE.PerspectiveCamera(60, 1, 0.1, 500);
    bufferCamera = new THREE.PerspectiveCamera( 60, 1, 0.1, 1000 );
    bufferCamera.position.z = 35;
    bufferScene.add(bufferCamera);

    var lightB = new THREE.DirectionalLight(0x888888);
    lightB.position.set(10, 20, 20);
    bufferScene.add(lightB);

    initModel(modelFile, vmdFiles);

    bufferTexture = new THREE.WebGLRenderTarget(
         1024, 1024, {
         minFilter: THREE.LinearFilter,
         magFilter: THREE.NearestFilter
         });

    ///////////////////
    var vertShader = document.getElementById('vsFilter').innerHTML;
    var fragShader = document.getElementById('fsFilter').innerHTML;
    material_shh = new THREE.ShaderMaterial({
      uniforms: {
        texture: {
        	type: 't',
          value: bufferTexture.texture
        },
        grain: {
        	type: 'f',
          value: 50
        }
      },
      vertexShader: vertShader,
      fragmentShader: fragShader
    });
    plan = new THREE.Mesh (new THREE.PlaneGeometry (20, 20),
        new THREE.MeshBasicMaterial({map:bufferTexture.texture}));
    plan.position.y = 10;
    //scene.add(plan);
    ///////////////////////////////////////////////////////////
    /*var vertShader2 = document.getElementById('vsFilter2').innerHTML;
    var fragShader2 = document.getElementById('fsFilter2').innerHTML;
    let allCenter = [], centers = [], plan2 = [];
	let LEDNums = 224, num = 195;
	for(let i=0;i<LEDNums;i++)
		console.log(i*1/LEDNums+1/LEDNums/2);
	for(let j = 0; j< num; j++){
		allCenter[j] = [];
		for(let i=0;i<LEDNums;i++){
		  allCenter[j][i] = new THREE.Vector2((1/num*j+0.05), i*2/LEDNums+2/LEDNums/2 );
		}
		//allCenter[j] = centers;
		let material_shh2 = new THREE.ShaderMaterial({
		  uniforms: {
			texture: {
				type: 't',
			  value: bufferTexture.texture
			},
			grain: {
				type: 'f',
			  value: 512
			},
			radius:{
			  type:'f',
			  value: 1/LEDNums/2
			},
			center:{
			  type:'v2v',
			  value: allCenter[j]
			}
		  },
		  vertexShader: vertShader2,
		  fragmentShader: fragShader2
		});
		//console.log(material_shh2.uniforms.center.value[0].x);
		plan2[j] = new THREE.Mesh (new THREE.PlaneGeometry (20, 20), material_shh2);
		plan2[j].position.y = 10;
		plan2[j].position.x = j*0.03;
		plan2[j].position.z = 1;
		//plan2.rotation.z = Math.PI/6 * j;
		scene.add(plan2[j]);
	}*/
	creatLED_Line();
  }

	function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	  renderer.setSize(window.innerWidth, window.innerHeight);
	}

	function animate() {
		stats.begin();
		stats.end();
		requestAnimationFrame(animate);
		var delta = clock.getDelta();
		angle += delta*60*1000;
		bufferCamera.rotation.z = angle;
		plan2[0].rotation.z = angle;
		plan2[1].rotation.z = angle;
		plan2[2].rotation.z = angle;

		helper.update(delta);
		effect.render(scene, camera);

		renderer.setRenderTarget(bufferTexture);
		renderer.render(bufferScene, bufferCamera);
		renderer.setRenderTarget(null);
		renderer.render(scene, camera);

		/*var read = new Uint8Array( 4 );
		for(let i=0;i<LEDNum;i++){
		  renderer.readRenderTargetPixels( bufferTexture, 512, i*(1024/LEDNum), 1, 1, read );
		  LEDs[i].material.color = new THREE.Color( read[ 0 ]/255, read[ 1 ]/255, read[ 2 ]/255 );
		}*/
	}

  function initModel(model, vmd){
    ///model

    function onProgress(xhr) {
      if (xhr.lengthComputable) {
        var percentComplete = xhr.loaded / xhr.total * 100;
        console.log(Math.round(percentComplete, 2) + '% downloaded');
      }
    };

    function onError(xhr) {};

    var loader = new MMDLoader();
    console.log(model);

    helper = new MMDAnimationHelper({
      afterglow: 2.0
    });

    loader.loadWithAnimation(model, vmd, function(mmd){
        mesh = mmd.mesh;
        mesh.position.set(0, -10, 0);
        bufferScene.add(mesh);

        helper.add( mesh, {
					animation: mmd.animation,
					physics: true
				} );


    },onProgress, onError);

  }
  function createLEDs(n){
    for(let i=0;i<n;i++){
       LEDs[i] = new THREE.Mesh(new THREE.CircleGeometry( 0.2, 20 ), new THREE.MeshBasicMaterial());
       LEDs[i].position.y = i*0.4;
       LEDs[i].position.x = 10;
       LEDs[i].position.z = 1;
       scene.add(LEDs[i]);
    }
  }
  function creatLED_Line(){
	var vertShader2 = document.getElementById('vsFilter2').innerHTML;
    var fragShader2 = document.getElementById('fsFilter2').innerHTML;
    let allCenter = []//, plan2 = [];
	let LEDNums = 224, num = 100;
	//直
	allCenter[0] = [];
	for(let i=0;i<LEDNums;i++){
	  allCenter[0][i] = new THREE.Vector2(0.5, i*2/LEDNums+2/LEDNums/2 );
	}
	let material_shh2 = new THREE.ShaderMaterial({
	  uniforms: {
		texture: {
			type: 't',
		  value: bufferTexture.texture
		},
		grain: {
			type: 'f',
		  value: 512
		},
		radius:{
		  type:'f',
		  value: 1/LEDNums/2*8
		},
		center:{
		  type:'v2v',
		  value: allCenter[0]
		}
	  },
	  vertexShader: vertShader2,
	  fragmentShader: fragShader2
	});
	//console.log(material_shh2.uniforms.center.value[0].x);
	plan2[0] = new THREE.Mesh (new THREE.PlaneGeometry (20, 20), material_shh2);
	plan2[0].position.y = 10;
	plan2[0].position.x = 0;
	plan2[0].position.z = 1;
	//plan2.rotation.z = Math.PI/6 * j;
	scene.add(plan2[0]);
	//橫
	allCenter[1] = [];
	for(let i=0;i<LEDNums;i++){
	  //allCenter[1][i] = new THREE.Vector2(i*2/LEDNums+2/LEDNums/2, 0.5 );
	  allCenter[1][i] = new THREE.Vector2(i*2/LEDNums+2/LEDNums/2, i*2/LEDNums+2/LEDNums/2 );
	}
	let material_shh3 = new THREE.ShaderMaterial({
	  uniforms: {
		texture: {
			type: 't',
		  value: bufferTexture.texture
		},
		grain: {
			type: 'f',
		  value: 512
		},
		radius:{
		  type:'f',
		  value: 1/LEDNums/2*8
		},
		center:{
		  type:'v2v',
		  value: allCenter[1]
		}
	  },
	  vertexShader: vertShader2,
	  fragmentShader: fragShader2
	});
	//console.log(material_shh2.uniforms.center.value[0].x);
	plan2[1] = new THREE.Mesh (new THREE.PlaneGeometry (20, 20), material_shh3);
	plan2[1].position.y = 10;
	plan2[1].position.x = 0;
	plan2[1].position.z = 1;
	//plan2[1].rotation.z = Math.PI/2;
	//plan2.rotation.z = Math.PI/6 * j;
	scene.add(plan2[1]);
	////////////////////////
	allCenter[2] = [];
	for(let i=0;i<LEDNums;i++){
	  allCenter[2][i] = new THREE.Vector2(i*2/LEDNums+2/LEDNums/2, 1-(i*2/LEDNums+2/LEDNums/2) );
	  /*let x = i*1/LEDNums+1/LEDNums/2;
	  let y = i*1/LEDNums+1/LEDNums/2;
	  let x2 = x*Math.cos(Math.PI/2) - y*Math.sin(Math.PI/2);
	  let y2 = x*Math.sin(Math.PI/2) + y*Math.cos(Math.PI/2);
	  allCenter[2][i] = new THREE.Vector2( x2, y2 );*/
	}
	let material_shh4 = new THREE.ShaderMaterial({
	  uniforms: {
		texture: {
			type: 't',
		  value: bufferTexture.texture
		},
		grain: {
			type: 'f',
		  value: 512
		},
		radius:{
		  type:'f',
		  value: 1/LEDNums/2*8
		},
		center:{
		  type:'v2v',
		  value: allCenter[2]
		}
	  },
	  vertexShader: vertShader2,
	  fragmentShader: fragShader2
	});
	//console.log(material_shh2.uniforms.center.value[0].x);
	plan2[2] = new THREE.Mesh (new THREE.PlaneGeometry (20, 20), material_shh4);
	plan2[2].position.y = 10;
	plan2[2].position.x = 0;
	plan2[2].position.z = 1;
	//plan2[1].rotation.z = Math.PI/2;
	//plan2.rotation.z = Math.PI/6 * j;
	scene.add(plan2[2]);
	
  }
  
</script>
</body>

</html>